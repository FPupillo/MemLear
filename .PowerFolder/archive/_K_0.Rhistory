library(beepr)
library(lme4)
library(lmerTest)
source("helper_functions/chooseMultinom.R")
source("helper_functions/chooseBinomial.R")
source("helper_functions/softmax.R")
source("computational_model/simulateObsAll.R")
source("helper_functions/InitVariab.R")
source("computational_model/simulateObsAll.R")
source("helper_functions/InitVariab.R")
source("computational_model/simulateObsAllTWF.R")
source("helper_functions/InitVariab.R")
source("computational_model/lik_RescorlaWagner_obsALL.R")
#mu<-c(0.75, 0.25)
mu <-c(0.70,0.15, 0.15)
#mu<-c(0.75, 0.25)
mu <-c(0.80,0.10, 0.10)
# how many scenes?
sceneNum<-length(mu)
# how many trials per scene
T<-60
# for the alpha, we could use average values
alphaMean<-0.43
alphaSD<-0.23
betaMean<- 7.99
betaSD<-7.24
interceptM<-0.49
interceptSD<-0.21
PEcoeffM<-0.21
PEcoeffSD<-0.08
participants<- 30
# simulate data first with 3 categories
alphas<-rnorm(n=participants, mean = alphaMean, sd = alphaSD)
# we need positive alphas
while(any (alphas<0)){
alphas<-rnorm(n=participants, mean = alphaMean, sd = alphaSD)
}
betas<-rnorm(n=participants, mean = betaMean, sd = betaSD)
# also positive betas
while(any (betas<0)){
betas<-rnorm(n=participants, mean = betaMean, sd = betaSD)
}
# create progress bar
pb<-txtProgressBar(min=0, max=participants, style=3)
for (n in 1: participants){
intercept<-rnorm(1, mean=interceptM, sd = interceptSD)
Pecoeff<-rnorm(1, mean=PEcoeffM, sd = PEcoeffSD)
#print(paste("Simulating participant"), 1)
sim1<-simulate_RW_obsALL(T, mu, alphas[n], betas[n])
Data<-sim1
estimateOBS<-lik_RescorlaWagner_obsALL(sim1, alphas[n], betas[n], 3, sceneNum )
estimateOBS$SubNum<-n
# memory perf
estimateOBS$recogAcc<-NA
for (t in 1: nrow(estimateOBS)){
estimateOBS$recogAcc[t]<-1/(1+exp(-(intercept+Pecoeff*estimateOBS$Delta[t])))
}
#progress bar
setTxtProgressBar(pb, n)
if (exists("DataAll")){
DataAll<-rbind(DataAll, estimateOBS)
} else{
DataAll<-estimateOBS
}
}
# simulate data first with 3 categories
alphas<-rnorm(n=participants, mean = alphaMean, sd = alphaSD)
# we need positive alphas
while(any (alphas<0)){
alphas<-rnorm(n=participants, mean = alphaMean, sd = alphaSD)
}
betas<-rnorm(n=participants, mean = betaMean, sd = betaSD)
# also positive betas
while(any (betas<0)){
betas<-rnorm(n=participants, mean = betaMean, sd = betaSD)
}
# create progress bar
pb<-txtProgressBar(min=0, max=participants, style=3)
for (n in 1: participants){
intercept<-rnorm(1, mean=interceptM, sd = interceptSD)
Pecoeff<-rnorm(1, mean=PEcoeffM, sd = PEcoeffSD)
#print(paste("Simulating participant"), 1)
sim1<-simulate_RW_obsALLTWF(T, mu, alphas[n], betas[n])
Data<-sim1
estimateOBS<-lik_RescorlaWagner_obsALL(sim1, alphas[n], betas[n], 3, sceneNum )
estimateOBS$SubNum<-n
# memory perf
estimateOBS$recogAcc<-NA
for (t in 1: nrow(estimateOBS)){
estimateOBS$recogAcc[t]<-1/(1+exp(-(intercept+Pecoeff*estimateOBS$Delta[t])))
}
#progress bar
setTxtProgressBar(pb, n)
if (exists("DataAll")){
DataAll<-rbind(DataAll, estimateOBS)
} else{
DataAll<-estimateOBS
}
}
betas
for (n in 1: participants){
intercept<-rnorm(1, mean=interceptM, sd = interceptSD)
Pecoeff<-rnorm(1, mean=PEcoeffM, sd = PEcoeffSD)
#print(paste("Simulating participant"), 1)
sim1<-simulate_RW_obsALLTWF(T, mu, alphas[n], betas[n])
Data<-sim1
estimateOBS<-lik_RescorlaWagner_obsALL(sim1, alphas[n], betas[n], 3, sceneNum )
estimateOBS$SubNum<-n
# memory perf
estimateOBS$recogAcc<-NA
for (t in 1: nrow(estimateOBS)){
estimateOBS$recogAcc[t]<-1/(1+exp(-(intercept+Pecoeff*estimateOBS$Delta[t])))
}
#progress bar
setTxtProgressBar(pb, n)
if (exists("DataAll")){
DataAll<-rbind(DataAll, estimateOBS)
} else{
DataAll<-estimateOBS
}
}
n<-1
intercept<-rnorm(1, mean=interceptM, sd = interceptSD)
Pecoeff<-rnorm(1, mean=PEcoeffM, sd = PEcoeffSD)
#print(paste("Simulating participant"), 1)
sim1<-simulate_RW_obsALLTWF(T, mu, alphas[n], betas[n])
View(simulate_RW_obsALLTWF)
mu
simulate_RW_obsALLTWF(T, mu1 = mu[1],mu2 = mu[2],1, alphas[n], betas[n])
changePoints<-1
# number of blocks
epochs<-changePoints+1
# categories: length of the probabilities
categories<-length(mu1)
#mu<-c(0.75, 0.25)
mu <-c(0.70,0.15, 0.15)
# how many scenes?
sceneNum<-length(mu)
# how many trials per scene
T<-80
# for the alpha, we could use average values
alphaMean<-0.43
alphaSD<-0.23
betaMean<- 7.99
betaSD<-7.24
interceptM<-0.49
interceptSD<-0.21
PEcoeffM<-0.21
PEcoeffSD<-0.08
participants<- 30
# simulate data first with 3 categories
alphas<-rnorm(n=participants, mean = alphaMean, sd = alphaSD)
# we need positive alphas
while(any (alphas<0)){
alphas<-rnorm(n=participants, mean = alphaMean, sd = alphaSD)
}
betas<-rnorm(n=participants, mean = betaMean, sd = betaSD)
# also positive betas
while(any (betas<0)){
betas<-rnorm(n=participants, mean = betaMean, sd = betaSD)
}
n<-1
# create progress bar
pb<-txtProgressBar(min=0, max=participants, style=3)
intercept<-rnorm(1, mean=interceptM, sd = interceptSD)
Pecoeff<-rnorm(1, mean=PEcoeffM, sd = PEcoeffSD)
#print(paste("Simulating participant"), 1)
sim1<-simulate_RW_obsALL(T, mu, alphas[n], betas[n])
#print(paste("Simulating participant"), 1)
sim1<-simulate_RW_obsALLTWF(T, mu,mu, alphas[n], betas[n])
#print(paste("Simulating participant"), 1)
sim1<-simulate_RW_obsALLTWF(T, mu,mu, 1,alphas[n], betas[n])
changePoints<-1
# number of blocks
epochs<-changePoints+1
# categories: length of the probabilities
categories<-length(mu1)
# # initialise matrix
data<-matrix(NA, nrow= T*epochs,ncol=3)
# counter for the matrix
counter2<-0
mu1<-mu
# categories: length of the probabilities
categories<-length(mu1)
# # initialise matrix
data<-matrix(NA, nrow= T*epochs,ncol=3)
# counter for the matrix
counter2<-0
# # update counter at every scene
counter1<-1+counter2
if (s == 1 | s == 3){ # for epoch 1 and 3, strong prior
# object category, the category displayed to participants
object_cat<-sample(seq(1:categories), T, prob=mu1, replace=T)
} else { # for epoch 2 and 4, flat prior
object_cat<-sample(seq(1:categories), T, prob=mu2, replace=T)
}
# initialise Q
Q<-rep(0.50, times=length(mu1))
s<-1
# initialise Q
Q<-rep(0.50, times=length(mu1))
# initialise a, the choice
a<-NULL
# initialize r
r<-NULL
# initialise a two element binary vector idicating which category is shown
x<-matrix(NA, nrow=T, ncol=2)
for (n in 1:length(object_cat)){
if (object_cat[n]==1){
x[n,]<-c(1,0)
} else if ((object_cat[n]==2)){
x[n,]<-c(0,1)
}
}
(s == 1 | s == 3)
# object category, the category displayed to participants
object_cat<-sample(seq(1:categories), T, prob=mu1, replace=T)
# initialise Q
Q<-rep(0.50, times=length(mu1))
# initialise a, the choice
a<-NULL
# initialize r
r<-NULL
# initialise a two element binary vector idicating which category is shown
x<-matrix(NA, nrow=T, ncol=2)
for (n in 1:length(object_cat)){
if (object_cat[n]==1){
x[n,]<-c(1,0)
} else if ((object_cat[n]==2)){
x[n,]<-c(0,1)
}
}
for(t in 1:T){
# compute choice probabilities
cp<-softmax(Q, beta)
# make choice according to choice probabilities
if (categories>2){
a[t] <- chooseMultinom(cp)
} else {a[t] <- chooseBinomial(cp) }
# the reinforcement here depends on the category shown, regardless of the choice
# update values
delta <- x[t,]-Q # subtracting x to the objectcategory, the category shown at the end
# update the Q related to the response according to the rw model
Q <-Q+ alpha *delta
}
beta<-3
for(t in 1:T){
# compute choice probabilities
cp<-softmax(Q, beta)
# make choice according to choice probabilities
if (categories>2){
a[t] <- chooseMultinom(cp)
} else {a[t] <- chooseBinomial(cp) }
# the reinforcement here depends on the category shown, regardless of the choice
# update values
delta <- x[t,]-Q # subtracting x to the objectcategory, the category shown at the end
# update the Q related to the response according to the rw model
Q <-Q+ alpha *delta
}
# compute choice probabilities
cp<-softmax(Q, beta)
# make choice according to choice probabilities
if (categories>2){
a[t] <- chooseMultinom(cp)
} else {a[t] <- chooseBinomial(cp) }
# update values
delta <- x[t,]-Q # subtracting x to the objectcategory, the category shown at the end
x[t,]
Q
mu<-c(0.75, 0.25)
changePoints<-1
# number of blocks
epochs<-changePoints+1
# categories: length of the probabilities
categories<-length(mu1)
mu1<-mu
# categories: length of the probabilities
categories<-length(mu1)
# # initialise matrix
data<-matrix(NA, nrow= T*epochs,ncol=3)
# counter for the matrix
counter2<-0
for ( s in 1:(epochs)){
# # update counter at every scene
counter1<-1+counter2
if (s == 1 | s == 3){ # for epoch 1 and 3, strong prior
# object category, the category displayed to participants
object_cat<-sample(seq(1:categories), T, prob=mu1, replace=T)
} else { # for epoch 2 and 4, flat prior
object_cat<-sample(seq(1:categories), T, prob=mu2, replace=T)
}
# initialise Q
Q<-rep(0.50, times=length(mu1))
# initialise a, the choice
a<-NULL
# initialize r
r<-NULL
# initialise a two element binary vector idicating which category is shown
x<-matrix(NA, nrow=T, ncol=2)
for (n in 1:length(object_cat)){
if (object_cat[n]==1){
x[n,]<-c(1,0)
} else if ((object_cat[n]==2)){
x[n,]<-c(0,1)
}
}
for(t in 1:T){
# compute choice probabilities
cp<-softmax(Q, beta)
# make choice according to choice probabilities
if (categories>2){
a[t] <- chooseMultinom(cp)
} else {a[t] <- chooseBinomial(cp) }
# the reinforcement here depends on the category shown, regardless of the choice
# update values
delta <- x[t,]-Q # subtracting x to the objectcategory, the category shown at the end
# update the Q related to the response according to the rw model
Q <-Q+ alpha *delta
}
# update the counter
counter2<-counter2+T
data[counter1:counter2,]<-cbind(rep(s, length=T),a, object_cat)
counter1<-counter1+T
}
alpha<-0.3
for(t in 1:T){
# compute choice probabilities
cp<-softmax(Q, beta)
# make choice according to choice probabilities
if (categories>2){
a[t] <- chooseMultinom(cp)
} else {a[t] <- chooseBinomial(cp) }
# the reinforcement here depends on the category shown, regardless of the choice
# update values
delta <- x[t,]-Q # subtracting x to the objectcategory, the category shown at the end
# update the Q related to the response according to the rw model
Q <-Q+ alpha *delta
}
# update the counter
counter2<-counter2+T
data[counter1:counter2,]<-cbind(rep(s, length=T),a, object_cat)
#print(paste("Simulating participant"), 1)
sim1<-simulate_RW_obsALLTWF(T, mu,mu, 1,alphas[n], betas[n])
mu
changePoints<-1
# number of blocks
epochs<-changePoints+1
# categories: length of the probabilities
categories<-length(mu1)
# # initialise matrix
data<-matrix(NA, nrow= T*epochs,ncol=3)
# counter for the matrix
counter2<-0
for ( s in 1:(epochs)){
# # update counter at every scene
counter1<-1+counter2
if (s == 1 | s == 3){ # for epoch 1 and 3, strong prior
# object category, the category displayed to participants
object_cat<-sample(seq(1:categories), T, prob=mu1, replace=T)
} else { # for epoch 2 and 4, flat prior
object_cat<-sample(seq(1:categories), T, prob=mu2, replace=T)
}
# initialise Q
Q<-rep(0.50, times=length(mu1))
# initialise a, the choice
a<-NULL
# initialize r
r<-NULL
# initialise a two element binary vector idicating which category is shown
x<-matrix(NA, nrow=T, ncol=2)
for (n in 1:length(object_cat)){
if (object_cat[n]==1){
x[n,]<-c(1,0)
} else if ((object_cat[n]==2)){
x[n,]<-c(0,1)
}
}
for(t in 1:T){
# compute choice probabilities
cp<-softmax(Q, beta)
# make choice according to choice probabilities
if (categories>2){
a[t] <- chooseMultinom(cp)
} else {a[t] <- chooseBinomial(cp) }
# the reinforcement here depends on the category shown, regardless of the choice
# update values
delta <- x[t,]-Q # subtracting x to the objectcategory, the category shown at the end
# update the Q related to the response according to the rw model
Q <-Q+ alpha *delta
}
# update the counter
counter2<-counter2+T
data[counter1:counter2,]<-cbind(rep(s, length=T),a, object_cat)
counter1<-counter1+T
}
mu2<-mu
for ( s in 1:(epochs)){
# # update counter at every scene
counter1<-1+counter2
if (s == 1 | s == 3){ # for epoch 1 and 3, strong prior
# object category, the category displayed to participants
object_cat<-sample(seq(1:categories), T, prob=mu1, replace=T)
} else { # for epoch 2 and 4, flat prior
object_cat<-sample(seq(1:categories), T, prob=mu2, replace=T)
}
# initialise Q
Q<-rep(0.50, times=length(mu1))
# initialise a, the choice
a<-NULL
# initialize r
r<-NULL
# initialise a two element binary vector idicating which category is shown
x<-matrix(NA, nrow=T, ncol=2)
for (n in 1:length(object_cat)){
if (object_cat[n]==1){
x[n,]<-c(1,0)
} else if ((object_cat[n]==2)){
x[n,]<-c(0,1)
}
}
for(t in 1:T){
# compute choice probabilities
cp<-softmax(Q, beta)
# make choice according to choice probabilities
if (categories>2){
a[t] <- chooseMultinom(cp)
} else {a[t] <- chooseBinomial(cp) }
# the reinforcement here depends on the category shown, regardless of the choice
# update values
delta <- x[t,]-Q # subtracting x to the objectcategory, the category shown at the end
# update the Q related to the response according to the rw model
Q <-Q+ alpha *delta
}
# update the counter
counter2<-counter2+T
data[counter1:counter2,]<-cbind(rep(s, length=T),a, object_cat)
counter1<-counter1+T
}
rm(list=ls())
# retrieve all the functions
library(ggplot2)
library(dplyr)
library(beepr)
library(lme4)
library(lmerTest)
source("helper_functions/chooseMultinom.R")
source("helper_functions/chooseBinomial.R")
source("helper_functions/softmax.R")
source("computational_model/simulateObsAll.R")
source("helper_functions/InitVariab.R")
source("computational_model/lik_RescorlaWagner_obsALL.R")
# probability
#mu<-c(0.80, 0.10, 0.10)
mu<-c(0.75, 0.25)
#mu <-c(0.70,0.15, 0.15)
# how many scenes?
sceneNum<-length(mu)
# how many trials per scene
T<-80
# for the alpha, we could use average values
alphaMean<-0.43
alphaSD<-0.23
betaMean<- 7.99
betaSD<-7.24
interceptM<-0.49
interceptSD<-0.21
PEcoeffM<-0.21
PEcoeffSD<-0.08
participants<- 30
# simulate data first with 3 categories
alphas<-rnorm(n=participants, mean = alphaMean, sd = alphaSD)
# we need positive alphas
while(any (alphas<0)){
alphas<-rnorm(n=participants, mean = alphaMean, sd = alphaSD)
}
betas<-rnorm(n=participants, mean = betaMean, sd = betaSD)
# also positive betas
while(any (betas<0)){
betas<-rnorm(n=participants, mean = betaMean, sd = betaSD)
}
intercept<-rnorm(1, mean=interceptM, sd = interceptSD)
Pecoeff<-rnorm(1, mean=PEcoeffM, sd = PEcoeffSD)
#print(paste("Simulating participant"), 1)
sim1<-simulate_RW_obsALLTWF(T, mu,mu, 1,alphas[n], betas[n])
Data<-sim1
source("computational_model/simulateObsAllTWF.R")
intercept<-rnorm(1, mean=interceptM, sd = interceptSD)
Pecoeff<-rnorm(1, mean=PEcoeffM, sd = PEcoeffSD)
#print(paste("Simulating participant"), 1)
sim1<-simulate_RW_obsALLTWF(T, mu,mu, 1,alphas[n], betas[n])
Data<-sim1
estimateOBS<-lik_RescorlaWagner_obsALL(sim1, alphas[n], betas[n], 3, sceneNum )
estimateOBS$SubNum<-n
intercept<-rnorm(1, mean=interceptM, sd = interceptSD)
Pecoeff<-rnorm(1, mean=PEcoeffM, sd = PEcoeffSD)
#print(paste("Simulating participant"), 1)
sim1<-simulate_RW_obsALLTWF(T, mu,mu, 1,alphas[n], betas[n])
n<-1
#print(paste("Simulating participant"), 1)
sim1<-simulate_RW_obsALLTWF(T, mu,mu, 1,alphas[n], betas[n])
Data<-sim1
estimateOBS<-lik_RescorlaWagner_obsALL(sim1, alphas[n], betas[n], 3, sceneNum )
sceneNum
Data<-sim1
estimateOBS<-lik_RescorlaWagner_obsALL(sim1, alphas[n], betas[n], 3, sceneNum )
estimateOBS<-lik_RescorlaWagner_obsALL(Data, alphas[n], betas[n], 3, sceneNum )
View(lik_RescorlaWagner_obsALL)
source("~/PowerFolders/Frankfurt_University/Prediction_learning/computational_model/lik_RescorlaWagner_obsALL.R", echo=TRUE)
estimateOBS<-lik_RescorlaWagner_obsALL(Data, alphas[n], betas[n], 3, sceneNum )
View(initVariab)
source("~/PowerFolders/Frankfurt_University/Prediction_learning/computational_model/lik_RescorlaWagner_obsALL.R", echo=TRUE)
estimateOBS<-lik_RescorlaWagner_obsALL(Data, alphas[n], betas[n], 3, sceneNum )
